% !TEX TS-program = pdflatex
% !TeX spellcheck = en_US
% !TEX root = lama-spec.tex
\chapter{Introduction}

\lama is a programming language developed by JetBrains Research for educational purposes as an exemplary language to introduce
the domain of programming languages, compilers and tools. Its general characteristics are:

\begin{itemize}
\item procedural with first-class functions~--- functions can be passed as arguments, placed in data structures,
  returned and ``constructed'' at runtime via closure mechanism;
\item with lexical static scoping;
\item strict~--- all arguments of function application are evaluated before function body;
\item imperative~--- variables can be re-assigned, function calls can have side effects;
\item untyped~--- no static type checking is performed;
\item with S-expressions and pattern-matching;
\item with user-defined infix operators, including those defined in local scopes;
\item with automatic memory management (garbage collection).
\end{itemize}

The name \lama is an acronym for $\lambda\textsc{-Algol}$ since the language has borrowed the syntactic shape of
operators from \textsc{Algol-68}~\cite{A68}; \textsc{Haskell}~\cite{haskell} and \textsc{OCaml}~\cite{ocaml} can be
mentioned as other languages of inspiration.

The main purpose of \lama is to present a repertoire of constructs with certain runtime behavior and
relevant implementation techniques. The lack of a type system (a vital feature for a real-word language
for software engineering) is an intensional decision which allows to show the unchained diversity
of runtime behaviors, including those which a typical type system is called to prevent. On the other hand
the language can be used in future as a raw substrate to apply various ways of software verification (including
type systems) on.

The current implementation contains a native code compiler for \textsc{x86-64}, written
in \textsc{OCaml}, a runtime library with garbage-collection support, written in \textsc{C}, and a small
standard library, written in \lama itself.

In addition, a source-level reference interpreter is implemented as well as a compiler to a small
stack machine. The stack machine code can in turn be either interpreted on a stack machine interpreter, or
used as an intermediate representation by the native code compiler.
